\section{Discussion}\label{sec:discussion}

Our preliminary results indicate that the rewrite rules in real-world Haskell
packages do not always define transformations between semantically equivalent
expressions. However, there are two key questions to consider in relation to these
results:
\smallskip

\textit{Validity}: Do failures in the test suites generated by \Rulecheck
correspond to differences that can be seen via application of rewrite rules?
\smallskip

\textit{Relevance}: When \Rulecheck correctly identifies that a rule does not
preserve semantic equality, does that mean the rule itself is actually incorrect
(and therefore, should be changed or removed)?
\smallskip

We now consider these questions in turn.

\subsection{Validity}

As described in \secref{methodology:testgen}, \Rulecheck does not utilize GHC's
rewriting mechanism to test rewrite rules; and instead opts to generates test
derived from the syntax of the rewrite rule. While this approach is superior in
terms of performance and excels at testing the underlying logic, it is possible
that failures in \Rulecheck generated tests could not occur via application of
the rule, for example, due to implementation details of GHC's rewriting engine.

However, as \Rulecheck is able to provide concrete counterexamples for test
failures, it seems possible to validate \Rulecheck's result by constructing
programs with the failing test inputs, and checking if a difference can be
observed in a version of the program compiled with rewrites enabled and without.
This process could even be automated and built-in to \Rulecheck, however we have
left this for future work. \ZGTODO{Try manual validation of some examples.}

\subsection{Relevance}

The question of relevance is less straightforward to resolve, because it
essentially depends on the context in which rewrite rules are defined. For
example, the \fastmath package considered in our case study defines rules that
can subtly change numerical computations and therefore, strictly speaking, do
not preserve the semantics of the program. Therefore, the rewrite rules in the
package are correct, in the sense that they do not need to be changed, despite
the failing tests in \Rulecheck.

Another threat to relevance is related to the treatment of well-typed
expressions that are nonetheless undefined. For example, the \texttt{arithmoi}
package defines a function \texttt{powMod}, where \texttt{powMod b e m} computes
the value $b^{e} \mod m$; but the behaviour of this function is undefined when
\texttt{e} is negative. \texttt{arithmoi} defines a rewrite rule that allows
\texttt{powMod} to be replaced with a specialized function
\texttt{powModInteger} when \texttt{b}, \texttt{e}, and \texttt{m} are all of
type \texttt{Integer}. \texttt{powMod b e m } and \texttt{powModInteger b e m}
exhibit different behaviour when \texttt{e} is negative: the first throws a
runtime exception, while the second simply returns \texttt{0}. However, this
difference does not indicate that the rewrite rule is incorrect, because it is
outside of the domain.

For now, the relevance of the failures identified by \Rulecheck can only be
determined by manual inspection and understanding of the relevant rewrite rules.
Due to time constraints, we have not yet systematically evaluated the relevance
of the failures identified in our evaluation. Further investigating this
question is a promising area of future work.
