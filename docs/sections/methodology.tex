\section{Methodology}
\label{sec:methodology}

Generating tests for rewrite rules comes with its own complications. First, rewritten expressions are intended to be \textit{semantically equivalent} to their source expressions, and what that means varies from library to library. For some, this is true contextual equivalence, and for others this is numerical approximation. To make matters worse, a rewrite may not even preserve user-defined boolean equality (from \texttt{class Eq}) - if that is even defined for the type! So in short, test generators need to remain flexible in the degree and manner in which they assert equality.

The flexibility of the rewrite system is another challenge. One of the few syntactic restrictions of rewrite rules is that ``the left hand side of a rule must consist of a top-level variable applied to arbitrary expressions'' \cite{userguide} - in so many words, rewrite rules can match arbitrary function applications, and transform terms of arbitrary types. These types are not required to implement any particular interfaces, nor are they even required to represent data! (They can be function-typed and are eta-expanded as needed.) Therefore, test generators need to be prepared to generate terms of a variety of types to act as inputs to or consume outputs from rule applications.

Finally, though parametricity greatly broadens the applicability of rules, it presents difficulties in test generation. Test generators must choose monotypes to instantiate rule polytypes, taking care that our choices implement any required typeclass constraints.

In summary, any test generator for rewrite rules must implement the following features:

\begin{itemize}
  \item Given a type, generate an arbitrary values of (instantiations of) that type
  \item Given two arbitrary values of the same type, compare them for semantic equality
\end{itemize}

\subsection{Generating arbitrary values}

Stuff here...

\subsection{Determining semantic equality}

Stuff here...
