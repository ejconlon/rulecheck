\section{Implementation}
\label{sec:implementation}

\Rulecheck consists of three components:

\begin{itemize}
  \item The \rctool test-suite generation tool
  \item A small runtime library for \rctool-generated test suites
  \item A library for program synthesis
\end{itemize}

We now go over each section in detail.

\subsection{The \rctool command-line tool}\label{sec:implementation:testgen}

The primary interface to \Rulecheck is the \rctool command-line tool. The
interface to \rctool is straightforward: it is provided as input the name of a
Haskell library containing rewrite rules, and outputs a test-suite containing a
property-based test for each rule in the library. The resulting test suite is a
standard \texttt{Cabal} test suite, and does not require the \rctool utility to
run. In the remainder of this section, we describe the details of the \rctool
implementation.

\begin{figure}
  \begin{minted}{haskell}
{- Test for Rule:
"builderBytes/bytes"
    forall a. builderBytes (bytes a) = a
-}
fn_lhs_rule1 :: ByteString -> ByteString
fn_lhs_rule1 a = builderBytes (bytes a)
fn_rhs_rule1 :: ByteString -> ByteString
fn_rhs_rule1 a = a
rule1 :: SomeTestableRule
rule1 = SomeTestableRule
  (TestableRule fn_lhs_rule1 fn_rhs_rule1)
test_rule1 :: TestTree
test_rule1 = test "builderByteszsbytes" rule1
   \end{minted}
   \caption{The property-based test generated by \rctool for the rule \texttt{forall a.
builderBytes (bytes a) = a} defined in the \texttt{bytestring-strict-builder}
library.}
    \label{fig:implementation:ruletest}
\end{figure}

\rctool begins by type-checking the source code of the input library using the
GHC API. This is necessary to obtain the type-checked representation of the
rewrite rules defined in the library, which will be used when generating
property-based tests. After type-checking, \rctool identifies the files in the
input library that contain rewrite rules. For each file containing rewrite
rules, it creates a corresponding test file; the test file contains a
property-based test for each rewrite rule defined in the input file.

\figref{implementation:ruletest} shows a simplified version of the
property-based test that \rctool generates for a rule in the
\texttt{bytestring-strict-builder} library. The test is generated from the
typechecked rule definition obtained from the GHC API. The function
\texttt{fn\_lhs\_rule1} generates an expression corresponding to the left-hand
side of the rewrite rule given a \texttt{ByteString} value \texttt{a};
\texttt{fn\_rhs\_rule1} generates the corresponding right-hand side. The
resulting test \texttt{test\_rule1} is interpreted by the \Rulecheck runtime
library, which generates arbitrary values for the parameter \texttt{a} and compares
the results of evaluating the functions for both sides of the rule.

In addition to generating tests, \Rulecheck also identifies the types of the
free variables of the rules, and uses our program synthesis library to attempt
to find expressions of those types. In the event that the \Rulecheck runtime
library does not know how to generate an expression of a necessary type, the
results of program synthesis can be used to create an appropriate
generator.

\subsection{The \Rulecheck Runtime Library}

The \Rulecheck runtime library, which is bundled into the resulting test suite,
is responsible for evaluating the property-based tests. It is responsible for
generating test inputs, and comparing test outputs.

The library is implemented as a wrapper around \texttt{QuickCheck}. Test inputs
are generated using \texttt{QuickCheck}'s \texttt{Arbitrary} instances. Test
outputs are first fully evaluated, and then compared as follows:
\begin{itemize}
  \item When comparing functions, \Rulecheck applies each function to the same
        arbitrary input, and compares the result.
  \item When comparing floating-point numbers, \Rulecheck checks if both numbers
are \texttt{NaN}. If so, \Rulecheck considers the outputs to be the same.
Otherwise it compares the numbers using the default equality operator
\texttt{(==)}.
  \item If the evaluation of both outputs resulted in an error, \Rulecheck
        considers the outputs to be the same. If only one output resulted in an error,
        then the \Rulecheck considers the results to be different.
  \item If the output type supports the \texttt{Eq} typeclass, then the outputs
        are compared using the equality operator \texttt{(==)}.
\end{itemize}

In this case where the runtime library encounters a type \texttt{a} for which it
cannot compare values, we can extend the library to support the type by
synthesizing a view function \texttt{(Eq b) => a -> b}, which can be used to
compare values of that type.

\subsection{Program Synthesis}\label{sec:implementation:synthesis}

\Rulecheck implements a tactics-based search for terms matching a given type, with fair interleaving and backtracking. \cite{delahaye2000tactic, kiselyov2005backtracking} It can be configured to read interface files in a format similar to Hoogle+ \cite{james2020digging} to define the sets of types and terms used in the search. Given a goal type, \Rulecheck derives terms of that type by repeatedly applying these tactics:

\begin{itemize}
  \item Yield a variable in the context (i.e. a function argument)
  \item Yield a literal (e.g. Int, String, etc)
  \item Yield a known term (e.g. functions or constants matching exactly)
  \item Apply a function and search for its arguments (where some partial application of the function matches the goal)
  \item Apply a function to a variable in the context
  \item Introduce a variable and search for a body (for function goals)
  \item Pattern match on an argument (for function goals with known argument constructors)
\end{itemize}

\Rulecheck directs the search by incrementally performing first-order unification on types. It also eagerly substitutes types implementing typeclass constraints, so it is important that all relevant instance declarations be included in the interface file. This process yields terms and their monotypes until terminated or until the search space is exhausted. \Rulecheck generally emits terms in A-normal form and does not support recursive definitions.

Haskell's type system is quite complex, made moreso by the variety of extensions it has accumulated over the years. \Rulecheck supports that simple core of functionality that is expressible with first-order unification. The most significant shortcoming in the current implementation is lack of support for unification of higher-kinded types, which is problematic when trying to derive programs with monadic binds. For example, one might wish to generate terms of type \texttt{Gen (Int, Int)} using the following interface file:

{
\smallskip
\begin{minted}{haskell}
class Monad m
return :: Monad m => a -> m a
bind :: Monad m => m a -> (a -> m b) -> m b

type Gen a
instance Monad Gen

class Arbitrary a
arbitrary :: Arbitrary a => Gen a
instance Arbitrary Int
\end{minted}
\smallskip
}

The problem arises when considering the declaration \texttt{class Monad m} in isolation; Haskell performs limited kind inference that we do not, from which it concludes that \texttt{m} is a type constructor, not a type. We do not yet collect kind information from our interface files, which is a prerequisite to annotating unification variables with kinds, and there are also some minor changes that need to be made to our unification algorithm to support them. Though we were not able to do so with the time limitations of this project, we believe we can support this feature and intend to do so soon.

Another noteworthy limitation of \Rulecheck is that it does not support \textit{higher-rank} types (those with additional \texttt{forall} quantifiers to the left of a function arrow, not just on the outside of the type). One can see this feature used for encapsulation in the \texttt{ST} and \texttt{Cont} monads, or in the core definitions of lens libraries. It was not easy for Haskell implementors to support these types in the first place \cite{jones2007practical}, so we have not given their synthesis much thought!
