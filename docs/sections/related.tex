\section{Related work}
\label{sec:related}

There is a long history of using types to guide automated testing of functional programs. \Quickcheck \cite{claessen2000quickcheck}, which we use extensively in this project, allows users to construct test input generators to validate lightweight logical specifications. These generators are commonly derived using typeclasses, meaning that the structure of a generator has a strong correspondence to structure of the type. \Quickcheck supports input shrinking, but this feature is not always useful in derived implementations. Projects such as \texttt{SmallCheck} \cite{runciman2008smallcheck} try to fix this by changing their strategy from generation to enumeration. Others like \texttt{Hedgehog} \cite{hedgehog} integrate shrinking directly into their generators, ensuring that shrinking always works, at the cost of complicating generator definitions.

Types have also been used extensively to direct program synthesis. In this work, we have no requirements for our generated programs aside from type compatibility, but many works describe the type- \textit{and} example-directed synthesis. \cite{osera2015type, feser2015synthesizing} Types constrain the search space to valid programs, and examples constrain the search space to relevant programs. Where fully automated search is insufficient, offering the user a selection of tactics can guide the system toward an answer. \cite{delahaye2000tactic} Automata-based representations \cite{koppel2022searching} are another alternative to tactics-based search for enumeration of program spaces with constraints.

Rewrite rules are a potential source of bugs in any term rewriting system. Notably, program generation has uncovered several bugs in SMT solvers. \cite{winterer2020validating}
