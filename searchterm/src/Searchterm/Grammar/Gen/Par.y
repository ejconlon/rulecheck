-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Searchterm.Grammar.Gen.Par
  ( happyError
  , myLexer
  , pLines
  , pLine
  , pListLine
  , pLit
  , pListLit
  , pListName
  ) where

import Prelude

import qualified Searchterm.Grammar.Gen.Abs
import Searchterm.Grammar.Gen.Lex
import qualified Data.Text

}

%name pLines Lines
%name pLine Line
%name pListLine ListLine
%name pLit Lit
%name pListLit ListLit
%name pListName ListName
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  ';'                { PT _ (TS _ 1)                }
  'constructors'     { PT _ (TS _ 2)                }
  'literals'         { PT _ (TS _ 3)                }
  'module'           { PT _ (TS _ 4)                }
  'type'             { PT _ (TS _ 5)                }
  L_charac           { PT _ (TC $$)                 }
  L_quoted           { PT _ (TL $$)                 }
  L_Name             { PT _ (T_Name $$)             }
  L_SignedInteger    { PT _ (T_SignedInteger $$)    }
  L_SignedScientific { PT _ (T_SignedScientific $$) }

%%

Char    :: { Char }
Char     : L_charac { (read (Data.Text.unpack $1)) :: Char }

String  :: { String }
String   : L_quoted { (Data.Text.unpack $1) }

Name :: { Searchterm.Grammar.Gen.Abs.Name }
Name  : L_Name { Searchterm.Grammar.Gen.Abs.Name $1 }

SignedInteger :: { Searchterm.Grammar.Gen.Abs.SignedInteger }
SignedInteger  : L_SignedInteger { Searchterm.Grammar.Gen.Abs.SignedInteger $1 }

SignedScientific :: { Searchterm.Grammar.Gen.Abs.SignedScientific }
SignedScientific  : L_SignedScientific { Searchterm.Grammar.Gen.Abs.SignedScientific $1 }

Lines :: { Searchterm.Grammar.Gen.Abs.Lines }
Lines : ListLine { Searchterm.Grammar.Gen.Abs.Lines $1 }

Line :: { Searchterm.Grammar.Gen.Abs.Line }
Line
  : 'type' Name ListName { Searchterm.Grammar.Gen.Abs.LineType $2 $3 }
  | 'constructors' Name ListName { Searchterm.Grammar.Gen.Abs.LineCons $2 $3 }
  | 'module' Name { Searchterm.Grammar.Gen.Abs.LineMod $2 }
  | 'literals' Name ListLit { Searchterm.Grammar.Gen.Abs.LineLit $2 $3 }

ListLine :: { [Searchterm.Grammar.Gen.Abs.Line] }
ListLine
  : {- empty -} { [] }
  | Line { (:[]) $1 }
  | Line ';' ListLine { (:) $1 $3 }

Lit :: { Searchterm.Grammar.Gen.Abs.Lit }
Lit
  : SignedScientific { Searchterm.Grammar.Gen.Abs.LitScientific $1 }
  | SignedInteger { Searchterm.Grammar.Gen.Abs.LitInteger $1 }
  | String { Searchterm.Grammar.Gen.Abs.LitString $1 }
  | Char { Searchterm.Grammar.Gen.Abs.LitChar $1 }

ListLit :: { [Searchterm.Grammar.Gen.Abs.Lit] }
ListLit : {- empty -} { [] } | Lit ListLit { (:) $1 $2 }

ListName :: { [Searchterm.Grammar.Gen.Abs.Name] }
ListName : {- empty -} { [] } | Name ListName { (:) $1 $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: Data.Text.Text -> [Token]
myLexer = tokens

}

