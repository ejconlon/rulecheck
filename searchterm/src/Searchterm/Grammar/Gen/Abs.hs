-- File generated by the BNF Converter (bnfc 2.9.4).

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}

-- | The abstract syntax of language Gen.

module Searchterm.Grammar.Gen.Abs where

import Prelude (Integer, String)
import qualified Prelude as C
  ( Eq, Ord, Show, Read
  , Functor, Foldable, Traversable
  , Int, Maybe(..)
  )
import qualified Data.String

import qualified Data.Text
import qualified Data.Data    as C (Data, Typeable)
import qualified GHC.Generics as C (Generic)

type Prog = Prog' BNFC'Position
data Prog' a = Prog a [Decl' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Decl = Decl' BNFC'Position
data Decl' a
    = DeclClass a (ClassDecl' a)
    | DeclFunc a (FuncDecl' a)
    | DeclVar a (VarDecl' a)
    | DeclStmt a (Stmt' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type ClassDecl = ClassDecl' BNFC'Position
data ClassDecl' a = ClassDecl a Ident (MayExtend' a) [FuncDecl' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type FuncDecl = FuncDecl' BNFC'Position
data FuncDecl' a = FuncDecl a Ident [Param' a] (Block' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type VarDecl = VarDecl' BNFC'Position
data VarDecl' a = VarDecl a Ident (MayDef' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Extend = Extend' BNFC'Position
data Extend' a = Extend a Ident
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Def = Def' BNFC'Position
data Def' a = Def a (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Stmt = Stmt' BNFC'Position
data Stmt' a
    = StmtFor a (ForStmt' a)
    | StmtIf a (IfStmt' a)
    | StmtPrint a (Exp' a)
    | StmtReturn a (Exp' a)
    | StmtWhile a (WhileStmt' a)
    | StmtBlock a (Block' a)
    | StmtAssign a (Assign' a)
    | StmtCall a (Call' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type ForStmt = ForStmt' BNFC'Position
data ForStmt' a
    = ForStmt a (MayForInit' a) (MayExp' a) (MayStmt' a) (Stmt' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type ForInit = ForInit' BNFC'Position
data ForInit' a
    = ForInitDecl a (VarDecl' a) | ForInitAssign a (Assign' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Assign = Assign' BNFC'Position
data Assign' a = Assign a (Target' a) (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type IfStmt = IfStmt' BNFC'Position
data IfStmt' a = IfStmt a (Exp' a) (Stmt' a) (MayElse' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Else = Else' BNFC'Position
data Else' a = Else a (Stmt' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type WhileStmt = WhileStmt' BNFC'Position
data WhileStmt' a = WhileStmt a (Exp' a) (Stmt' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Block = Block' BNFC'Position
data Block' a = Block a [Decl' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type KnownTarget = KnownTarget' BNFC'Position
data KnownTarget' a
    = KnownTarget a (KnownTargetHead' a) (MayKnownTargetTail' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type KnownTargetHead = KnownTargetHead' BNFC'Position
data KnownTargetHead' a
    = KnownTargetHeadThis a
    | KnownTargetHeadSuper a
    | KnownTargetHeadIdent a Ident
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type KnownTargetTail = KnownTargetTail' BNFC'Position
data KnownTargetTail' a
    = KnownTargetTail a Ident (MayKnownTargetTail' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Exp = Exp' BNFC'Position
data Exp' a
    = ExpNil a
    | ExpTarget a (Target' a)
    | ExpVar a Ident
    | ExpLit a (Lit' a)
    | ExpOp a (Op' a)
    | ExpCall a (Call' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Call = Call' BNFC'Position
data Call' a = Call a (Target' a) [Arg' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Target = Target' BNFC'Position
data Target' a
    = TargetKnown a (KnownTarget' a) | TargetExp a (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Lit = Lit' BNFC'Position
data Lit' a
    = LitBool a (BoolLit' a) | LitInt a Integer | LitString a String
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type BoolLit = BoolLit' BNFC'Position
data BoolLit' a = BoolLitTrue a | BoolLitFalse a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Op = Op' BNFC'Position
data Op' a
    = OpBool a (BoolOp' a)
    | OpNum a (NumOp' a)
    | OpCmp a (CmpOp' a)
    | OpStr a (StrOp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type BoolOp = BoolOp' BNFC'Position
data BoolOp' a
    = BoolOpBin a (Exp' a) (BoolBinOp' a) (Exp' a)
    | BoolOpUn a (BoolUnOp' a) (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type BoolBinOp = BoolBinOp' BNFC'Position
data BoolBinOp' a = BoolBinOpOr a | BoolBinOpAnd a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type BoolUnOp = BoolUnOp' BNFC'Position
data BoolUnOp' a = BoolUnOpNot a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type CmpOp = CmpOp' BNFC'Position
data CmpOp' a = CmpOpBin a (Exp' a) (CmpBinOp' a) (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type CmpBinOp = CmpBinOp' BNFC'Position
data CmpBinOp' a
    = CmpBinOpEq a
    | CmpBinOpNe a
    | CmpBinOpGt a
    | CmpBinOpGe a
    | CmpBinOpLt a
    | CmpBinOpLe a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type NumOp = NumOp' BNFC'Position
data NumOp' a
    = NumOpBin a (Exp' a) (NumBinOp' a) (Exp' a)
    | NumOpUn a (NumUnOp' a) (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type NumBinOp = NumBinOp' BNFC'Position
data NumBinOp' a
    = NumBinOpAdd a | NumBinOpSub a | NumBinOpMul a | NumBinOpDiv a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type NumUnOp = NumUnOp' BNFC'Position
data NumUnOp' a = NumUnOpNeg a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type StrOp = StrOp' BNFC'Position
data StrOp' a = StrOpBin a (Exp' a) (StrBinOp' a) (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type StrBinOp = StrBinOp' BNFC'Position
data StrBinOp' a = StrBinOpAppend a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Param = Param' BNFC'Position
data Param' a = Param a Ident
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Arg = Arg' BNFC'Position
data Arg' a = Arg a (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type MayExtend = MayExtend' BNFC'Position
data MayExtend' a = MayExtendNone a | MayExtendSome a (Extend' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type MayDef = MayDef' BNFC'Position
data MayDef' a = MayDefNone a | MayDefSome a (Def' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type MayExp = MayExp' BNFC'Position
data MayExp' a = MayExpNone a | MayExpSome a (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type MayVarDecl = MayVarDecl' BNFC'Position
data MayVarDecl' a
    = MayVarDeclNone a | MayVarDeclSome a (VarDecl' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type MayElse = MayElse' BNFC'Position
data MayElse' a = MayElseNone a | MayElseSome a (Else' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type MayStmt = MayStmt' BNFC'Position
data MayStmt' a = MayStmtNone a | MayStmtSome a (Stmt' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type MayForInit = MayForInit' BNFC'Position
data MayForInit' a
    = MayForInitNone a | MayForInitSome a (ForInit' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type MayKnownTargetTail = MayKnownTargetTail' BNFC'Position
data MayKnownTargetTail' a
    = MayKnownTargetTailNone a
    | MayKnownTargetTailSome a (KnownTargetTail' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

newtype Ident = Ident Data.Text.Text
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic, Data.String.IsString)

-- | Start position (line, column) of something.

type BNFC'Position = C.Maybe (C.Int, C.Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = C.Nothing

pattern BNFC'Position :: C.Int -> C.Int -> BNFC'Position
pattern BNFC'Position line col = C.Just (line, col)

-- | Get the start position of something.

class HasPosition a where
  hasPosition :: a -> BNFC'Position

instance HasPosition Prog where
  hasPosition = \case
    Prog p _ -> p

instance HasPosition Decl where
  hasPosition = \case
    DeclClass p _ -> p
    DeclFunc p _ -> p
    DeclVar p _ -> p
    DeclStmt p _ -> p

instance HasPosition ClassDecl where
  hasPosition = \case
    ClassDecl p _ _ _ -> p

instance HasPosition FuncDecl where
  hasPosition = \case
    FuncDecl p _ _ _ -> p

instance HasPosition VarDecl where
  hasPosition = \case
    VarDecl p _ _ -> p

instance HasPosition Extend where
  hasPosition = \case
    Extend p _ -> p

instance HasPosition Def where
  hasPosition = \case
    Def p _ -> p

instance HasPosition Stmt where
  hasPosition = \case
    StmtFor p _ -> p
    StmtIf p _ -> p
    StmtPrint p _ -> p
    StmtReturn p _ -> p
    StmtWhile p _ -> p
    StmtBlock p _ -> p
    StmtAssign p _ -> p
    StmtCall p _ -> p

instance HasPosition ForStmt where
  hasPosition = \case
    ForStmt p _ _ _ _ -> p

instance HasPosition ForInit where
  hasPosition = \case
    ForInitDecl p _ -> p
    ForInitAssign p _ -> p

instance HasPosition Assign where
  hasPosition = \case
    Assign p _ _ -> p

instance HasPosition IfStmt where
  hasPosition = \case
    IfStmt p _ _ _ -> p

instance HasPosition Else where
  hasPosition = \case
    Else p _ -> p

instance HasPosition WhileStmt where
  hasPosition = \case
    WhileStmt p _ _ -> p

instance HasPosition Block where
  hasPosition = \case
    Block p _ -> p

instance HasPosition KnownTarget where
  hasPosition = \case
    KnownTarget p _ _ -> p

instance HasPosition KnownTargetHead where
  hasPosition = \case
    KnownTargetHeadThis p -> p
    KnownTargetHeadSuper p -> p
    KnownTargetHeadIdent p _ -> p

instance HasPosition KnownTargetTail where
  hasPosition = \case
    KnownTargetTail p _ _ -> p

instance HasPosition Exp where
  hasPosition = \case
    ExpNil p -> p
    ExpTarget p _ -> p
    ExpVar p _ -> p
    ExpLit p _ -> p
    ExpOp p _ -> p
    ExpCall p _ -> p

instance HasPosition Call where
  hasPosition = \case
    Call p _ _ -> p

instance HasPosition Target where
  hasPosition = \case
    TargetKnown p _ -> p
    TargetExp p _ -> p

instance HasPosition Lit where
  hasPosition = \case
    LitBool p _ -> p
    LitInt p _ -> p
    LitString p _ -> p

instance HasPosition BoolLit where
  hasPosition = \case
    BoolLitTrue p -> p
    BoolLitFalse p -> p

instance HasPosition Op where
  hasPosition = \case
    OpBool p _ -> p
    OpNum p _ -> p
    OpCmp p _ -> p
    OpStr p _ -> p

instance HasPosition BoolOp where
  hasPosition = \case
    BoolOpBin p _ _ _ -> p
    BoolOpUn p _ _ -> p

instance HasPosition BoolBinOp where
  hasPosition = \case
    BoolBinOpOr p -> p
    BoolBinOpAnd p -> p

instance HasPosition BoolUnOp where
  hasPosition = \case
    BoolUnOpNot p -> p

instance HasPosition CmpOp where
  hasPosition = \case
    CmpOpBin p _ _ _ -> p

instance HasPosition CmpBinOp where
  hasPosition = \case
    CmpBinOpEq p -> p
    CmpBinOpNe p -> p
    CmpBinOpGt p -> p
    CmpBinOpGe p -> p
    CmpBinOpLt p -> p
    CmpBinOpLe p -> p

instance HasPosition NumOp where
  hasPosition = \case
    NumOpBin p _ _ _ -> p
    NumOpUn p _ _ -> p

instance HasPosition NumBinOp where
  hasPosition = \case
    NumBinOpAdd p -> p
    NumBinOpSub p -> p
    NumBinOpMul p -> p
    NumBinOpDiv p -> p

instance HasPosition NumUnOp where
  hasPosition = \case
    NumUnOpNeg p -> p

instance HasPosition StrOp where
  hasPosition = \case
    StrOpBin p _ _ _ -> p

instance HasPosition StrBinOp where
  hasPosition = \case
    StrBinOpAppend p -> p

instance HasPosition Param where
  hasPosition = \case
    Param p _ -> p

instance HasPosition Arg where
  hasPosition = \case
    Arg p _ -> p

instance HasPosition MayExtend where
  hasPosition = \case
    MayExtendNone p -> p
    MayExtendSome p _ -> p

instance HasPosition MayDef where
  hasPosition = \case
    MayDefNone p -> p
    MayDefSome p _ -> p

instance HasPosition MayExp where
  hasPosition = \case
    MayExpNone p -> p
    MayExpSome p _ -> p

instance HasPosition MayVarDecl where
  hasPosition = \case
    MayVarDeclNone p -> p
    MayVarDeclSome p _ -> p

instance HasPosition MayElse where
  hasPosition = \case
    MayElseNone p -> p
    MayElseSome p _ -> p

instance HasPosition MayStmt where
  hasPosition = \case
    MayStmtNone p -> p
    MayStmtSome p _ -> p

instance HasPosition MayForInit where
  hasPosition = \case
    MayForInitNone p -> p
    MayForInitSome p _ -> p

instance HasPosition MayKnownTargetTail where
  hasPosition = \case
    MayKnownTargetTailNone p -> p
    MayKnownTargetTailSome p _ -> p

